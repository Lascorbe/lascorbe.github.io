<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Luis Ascorbe"/><link rel="canonical" href="https://lascorbe.com/posts/2020-04-27-MVPCoordinators-SwiftUI-part1"/><meta name="twitter:url" content="https://lascorbe.com/posts/2020-04-27-MVPCoordinators-SwiftUI-part1"/><meta name="og:url" content="https://lascorbe.com/posts/2020-04-27-MVPCoordinators-SwiftUI-part1"/><title>MVP + Coordinators in SwiftUI (part 1) | Luis Ascorbe</title><meta name="twitter:title" content="MVP + Coordinators in SwiftUI (part 1) | Luis Ascorbe"/><meta name="og:title" content="MVP + Coordinators in SwiftUI (part 1) | Luis Ascorbe"/><meta name="description" content="We'll learn how to set up an entire screen with the MVP pattern, we'll create a base Coordinator protocol, and implement our first 2 coordinators. We'll see how to wrap our view in a NavigationView, and how we can implement NavigationLink so it doesn't depend on anything else in the view. Are you ready? Tap me!"/><meta name="twitter:description" content="We'll learn how to set up an entire screen with the MVP pattern, we'll create a base Coordinator protocol, and implement our first 2 coordinators. We'll see how to wrap our view in a NavigationView, and how we can implement NavigationLink so it doesn't depend on anything else in the view. Are you ready? Tap me!"/><meta name="og:description" content="We'll learn how to set up an entire screen with the MVP pattern, we'll create a base Coordinator protocol, and implement our first 2 coordinators. We'll see how to wrap our view in a NavigationView, and how we can implement NavigationLink so it doesn't depend on anything else in the view. Are you ready? Tap me!"/><meta name="twitter:card" content="summary"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Luis Ascorbe"/><meta name="twitter:image" content="https://lascorbe.com/android-chrome-512x512.png"/><meta name="og:image" content="https://lascorbe.com/android-chrome-512x512.png"/><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/pure-min.css" integrity="sha384-oAOxQR6DkCoMliIh8yFnu25d7Eq/PHS21PClpwjOTeU2jRSq11vu66rf90/cZr47" crossorigin="anonymous"/><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/grids-responsive-min.css" type="text/css"/><link rel="stylesheet" href="/Pure/styles.css" type="text/css"/><link rel="stylesheet" href="/FontAwesomeCSS/all.css" type="text/css"/><link rel="icon" href="/favicon-32x32.png" type="image/png" sizes="32x32"/><link rel="icon" href="/favicon-16x16.png" type="image/png" sizes="16x16"/><link rel="apple-touch-icon" href="/apple-touch-icon.png" type="image/png" sizes="180x180"/><link rel="manifest" href="/site.webmanifest"/></head><body><div id="layout" class="pure-g"><div class="sidebar pure-u-1 pure-u-md-1-4"><div class="sidebar-header"><div><div class="pure-menu pure-menu-horizontal"><ul class="pure-menu-list"><li class="pure-menu-item pure-menu-selected"><a class="pure-menu-link" href="/">Blog</a></li><li class="pure-menu-item pure-menu-selected"><a class="pure-menu-link" href="/about">About</a></li></ul></div></div></div><div class="sidebar-profile"><div id="layout" class="pure-g"><div class="author__avatar"><img src="https://avatars0.githubusercontent.com/u/1515520?s=460&v=4"/></div><div class="pure-u-md-1-1 pure-u-3-4"><h1 class="brand-title"><a href="/">Luis Ascorbe</a></h1><h3 class="brand-tagline">Software Developer. Tech Lead. Speaker. Conference Organizer.</h3></div></div><div class="social-media-container"><div id="layout" class="pure-g"><div class="pure-u-md-1-1"><a href="mailto:hi+blog@ascor.be" target="_blank"><i class="far fa-envelope l-box social-icon"></i><a class="social-media" href="mailto:hi+blog@ascor.be" target="_blank">Email</a></a></div><div class="pure-u-md-1-1"><a href="https://github.com/lascorbe" target="_blank"><i class="fab fa-github l-box social-icon"></i><a class="social-media" href="https://github.com/lascorbe" target="_blank">GitHub</a></a></div><div class="pure-u-md-1-1"><a href="https://twitter.com/lascorbe" target="_blank"><i class="fab fa-twitter l-box social-icon"></i><a class="social-media" href="https://twitter.com/lascorbe" target="_blank">Twitter</a></a></div><div class="pure-u-md-1-1"><a href="https://www.linkedin.com/in/lascorbe" target="_blank"><i class="fab fa-linkedin l-box social-icon"></i><a class="social-media" href="https://www.linkedin.com/in/lascorbe" target="_blank">LinkedIn</a></a></div></div></div></div></div><div class="content pure-u-1 pure-u-md-3-4 pure-u-xl-6-10"><h2 class="post-title">MVP + Coordinators in SwiftUI (part 1)</h2><p class="post-meta">27 April 2020 ¬∑ ‚è± 15 minutes</p><div class="post-tags"><a class="post-category post-category-swiftui" href="/tags/swiftui">swiftui</a><a class="post-category post-category-coordinator" href="/tags/coordinator">coordinator</a><a class="post-category post-category-mvp" href="/tags/mvp">mvp</a><a class="post-category post-category-article" href="/tags/article">article</a><a class="post-category post-category-series" href="/tags/series">series</a><a class="post-category post-category-part1" href="/tags/part1">part1</a></div><div class="post-description"><div class="description-text"><img src="/images/posts/2020-04-26-MVPCoordinators-SwiftUI/1.jpg"/><p><em>Public repo: For those of you who want to check out the code right away here is the repo: <a href="https://github.com/Lascorbe/SwiftUI-MVP-Coordinator">https://github.com/Lascorbe/SwiftUI-MVP-Coordinator</a>.</em></p><p><em>Note: This is a blog series of 3 parts. This is the first part, and here is <a href="https://lascorbe.com/posts/2020-04-28-MVPCoordinators-SwiftUI-part2">part 2</a> and <a href="https://lascorbe.com/posts/2020-04-29-MVPCoordinators-SwiftUI-part3">part 3</a>.</em></p><p><strong>I didn't want to do much on SwiftUI until the next version is announced</strong> due to my previous experience with Swift, I mean, it'll likely introduce a lot of breaking changes. I still remember the pain of migrating between Swift versions (Swift 3 to 4 anyone?), and I didn't want to live that again.</p><p>But all changed, quarantine arrived and I wanted to give a hand building a new app for a friend. I thought well, it could be nice to try SwiftUI making a real app. I liked what I saw about it until now, but after using it... what a great tool it is! <strong>Something that took you 2 days to do with UIKit now you can do it in 2 hours</strong>, it just boosts development so much. It's what we were waiting for while we were looking at things like hot reloading of our frontend colleagues, or React Native, or Flutter... Plus a declarative layout, nothing left to ask for.</p><p>But in SwiftUI not everything is a land of unicorns, specially when you discover that not only navigation is a bit tied to the views, but <a href="https://twitter.com/Dimillian/status/1184745928739184640?s=20">there're</a> <a href="https://twitter.com/tomatoterrorist/status/1242823885621350401?s=20">some</a> <a href="https://twitter.com/SwiftUILab/status/1156091686151475200?s=20">broken</a> <a href="https://twitter.com/ishabazz/status/1234274177231638529?s=20">things</a> <a href="https://twitter.com/search?q=broken%20swiftui&src=typed_query">between iOS 13 minor versions</a> and other platforms.</p><p>I can't do much about how broken an Apple framework/tool is (above reporting <s>radars</s> <a href="https://feedbackassistant.apple.com">feedbacks</a>), but I can explore <strong>how navigation can be decoupled from Views</strong>, or at least I can try. Also, <a href="https://twitter.com/Lascorbe/status/1253992068814430209?s=20">looks like there's some interest</a>.</p><p>So in this post <strong>I'm going to show you how to use SwiftUI with Coordinators</strong>, and using the MVP design pattern.</p><p>I choose MVP and <a href="https://khanlou.com/2015/10/coordinators-redux/">Coordinators</a>, because I've worked with both, and because Coordinators became the defacto design pattern to route our navigation in a UIKit app (<a href="https://vimeo.com/144116310">thanks Soroush! üòä</a>). I don't know if those 2 are the best design patterns to use with SwiftUI, maybe not, maybe something like redux would fit better, I don't know. But it doesn't hurt to try.</p><p>I'm not going to explain how coordinators work, <a href="https://khanlou.com/2015/10/coordinators-redux/">there're</a> <a href="https://www.hackingwithswift.com/articles/175/advanced-coordinator-pattern-tutorial-ios">several</a> <a href="https://khanlou.com/tag/advanced-coordinators/">blog posts</a> explaining it far better and from smarter people than me, which I recommend you to check out if you haven't.</p><p>One more thing before we get started. <strong>I created this project thinking in a big app, with testing in mind.</strong> That's why you'll see an interface for most of the types (aka protocols), so everything can be mocked and tested.</p><p><strong>In this part, part 1</strong>, we're going to learn how to set up an entire screen with the MVP pattern, we'll create a base <code>Coordinator</code> protocol, and implement our first 2 coordinators. We'll see how to wrap our view in a NavigationView, and how we can implement NavigationLink so it doesn't depend on anything else in the view.</p><p>In the next section, we're going to see how to set up our 1st screen with MVP (Model-View-Presenter). Create a new project/playground and let's make our first view.</p><h2>1. ‚å®Ô∏è Setting up our first screen with MVP</h2><p>With our project created, let's define the 1st view of our app:</p><pre><code><span class="la-keyword">struct</span> MasterView: <span class="la-type">View</span> {
    <span class="la-keyword">var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-type">Text</span>(<span class="la-string">"We will rock the stage at NSSpain again"</span>)
    }
}
</code></pre><p>I really want to try to void words like "just", "easy", "simple", "complex"... but this is literally <em>just</em> one label in the middle of the screen.</p><p>Now the model, <em>just</em> storing a date (I'll call them ViewModels because we're at the UI layer):</p><pre><code><span class="la-keyword">struct</span> MasterViewModel {
    <span class="la-keyword">let</span> date: <span class="la-type">Date</span>
}
</code></pre><p>Now the presenter:</p><pre><code><span class="la-keyword">protocol</span> MasterPresenting: <span class="la-type">ObservableObject</span> { <span class="la-comment">// Notice conformance to ObservableObject</span>
    <span class="la-keyword">var</span> viewModel: <span class="la-type">MasterViewModel</span> { <span class="la-keyword">get</span> }
}

<span class="la-keyword">final class</span> MasterPresenter: <span class="la-type">MasterPresenting</span> {
    <span class="la-keyword">@Published private(set) var</span> viewModel = <span class="la-type">MasterViewModel</span>(date: <span class="la-type">Date</span>())
}
</code></pre><p>Yes, we're doing protocols all the way. This is going to be a small app, but let's treat it as if it was a big one. We declare the protocol of the presenter, so we can inject it in our view, which will make things like testing easier.</p><p>Using the power of Combine, we declared the protocol conformance to <code>ObservableObject</code>. Now we can observe the <code>@Published</code> properties from the view.</p><p>Let's change our view to adopt this presenter protocol:</p><pre><code><span class="la-keyword">struct</span> MasterView: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">MasterPresenting</span> <span class="la-comment">// check out @ObservedObject</span>
  
    <span class="la-keyword">var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-type">Text</span>(<span class="la-string">"</span>\(presenter.<span class="la-property">viewModel</span>.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>)
    }
}
</code></pre><p>To bind this view to the presenter we need the <code>@ObservedObject</code> property wrapper. <code>dateFormatter</code> is just a global <code>DateFormatter</code> defined somewhere else. Now our view is "listening" for whenever our <code>viewModel</code> changes!</p><p>But since <code>MasterPresenting</code> is conforming to <code>ObservableObject</code>, it is a generic protocol. So we have to tell that to the view:</p><pre><code><span class="la-keyword">struct</span> MasterView&lt;T: <span class="la-type">MasterPresenting</span>&gt;: <span class="la-type">View</span> { <span class="la-comment">// hi there T!</span>
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">T</span>
  
    {...}
}
</code></pre><p>We still don't want <code>MasterView</code> to know what <code>MasterPresenting</code> we are injecting, so let's keep using the <code>MasterPresenting</code> protocol, this time as a generic one (<code>&lt;T: MasterPresenting&gt;</code>).</p><p>We've completed the MVP part of our first screen. <strong>In the next section we're going to define our base Coordinator type and define our first 2 coordinators</strong>.</p><p>This is what we've done so far:</p><pre><code><span class="la-keyword">struct</span> MasterViewModel {
    <span class="la-keyword">let</span> date: <span class="la-type">Date</span>
}

<span class="la-keyword">protocol</span> MasterPresenting: <span class="la-type">ObservableObject</span> {
    <span class="la-keyword">var</span> viewModel: <span class="la-type">MasterViewModel</span> { <span class="la-keyword">get</span> }
}

<span class="la-keyword">final class</span> MasterPresenter: <span class="la-type">MasterPresenting</span> {
    <span class="la-keyword">@Published private(set) var</span> viewModel = <span class="la-type">MasterViewModel</span>(date: <span class="la-type">Date</span>())
}

<span class="la-keyword">struct</span> MasterView&lt;T: <span class="la-type">MasterPresenting</span>&gt;: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">T</span>
  
    <span class="la-keyword">var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-type">Text</span>(<span class="la-string">"</span>\(presenter.<span class="la-property">viewModel</span>.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>)
    }
}
</code></pre><h2>2. üß≠ Creating Coordinators</h2><p>With our MVP in place, now we are going to create protocols and implementations for coordinators. So how does our base Coordinator look like?</p><pre><code><span class="la-keyword">protocol</span> Coordinator {
    <span class="la-keyword">func</span> start()
}
</code></pre><p>Let's start with something like this. And we extend the protocol to define a coordinate function:</p><pre><code><span class="la-keyword">extension</span> <span class="la-type">Coordinator</span> {
    <span class="la-keyword">func</span> coordinate(to coordinator: <span class="la-type">Coordinator</span>) {
        coordinator.<span class="la-property">parent</span> = <span class="la-keyword">self</span>
        coordinator.<span class="la-call">start</span>()
    }
}
</code></pre><p>Wait, how are you storing parent in a protocol extension? Where is it defined? Bear with me for a moment, we'll get there.</p><p>Next, we can try to implement <code>MasterView</code>'s coordinator:</p><pre><code><span class="la-keyword">protocol</span> MasterCoordinator: <span class="la-type">Coordinator</span> {} <span class="la-comment">// empty for now</span>

<span class="la-keyword">final class</span> RootMasterCoordinator: <span class="la-type">MasterCoordinator</span> {
    <span class="la-keyword">func</span> start() {
        ??
    }
}
</code></pre><p>Hmmm, what can we do here? Let's go to the beginning of the app, the <code>SceneDelegate</code>, and see what we need.</p><pre><code><span class="la-keyword">func</span> scene(<span class="la-keyword">_</span> scene: <span class="la-type">UIScene</span>, willConnectTo session: <span class="la-type">UISceneSession</span>, options connectionOptions: <span class="la-type">UIScene</span>.<span class="la-type">ConnectionOptions</span>) {
    <span class="la-keyword">if let</span> windowScene = scene <span class="la-keyword">as</span>? <span class="la-type">UIWindowScene</span> {
        <span class="la-keyword">let</span> window = <span class="la-type">UIWindow</span>(windowScene: windowScene)
        <span class="la-keyword">let</span> coordinator = <span class="la-type">AppCoordinator</span>(window: window) <span class="la-comment">// &lt;-- look here</span>
        coordinator.<span class="la-call">start</span>()                              <span class="la-comment">// &lt;-- and here</span>
        <span class="la-keyword">self</span>.<span class="la-property">window</span> = window
    }
}
</code></pre><p>The important part is the 2 lines of the coordinator, the initialization, where we inject the window, and <code>coordinator.start()</code>. Now let's define our <code>AppCoordinator</code>, which is going to be the starting point of the app navigation:</p><pre><code><span class="la-keyword">final class</span> AppCoordinator: <span class="la-type">Coordinator</span> {
    <span class="la-keyword">private weak var</span> window: <span class="la-type">UIWindow</span>?
    
    <span class="la-keyword">init</span>(window: <span class="la-type">UIWindow</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">window</span> = window
    }
    
    <span class="la-keyword">func</span> start() {
        <span class="la-keyword">let</span> coordinator = <span class="la-type">RootMasterCoordinator</span>(window: window)
        <span class="la-call">coordinate</span>(to: coordinator)
    }
}
</code></pre><p>We're injecting the <code>UIWindow</code> through the <code>init</code>, and then passing it to <code>MasterView</code>'s coordinator.</p><p>Next, we have to handle the presentation on the window. Let's go back to our <code>RootMasterCoordinator</code> and set up the <code>start()</code> function:</p><pre><code><span class="la-keyword">final class</span> RootMasterCoordinator: <span class="la-type">MasterCoordinator</span> {
    <span class="la-keyword">private weak var</span> window: <span class="la-type">UIWindow</span>?
    
    <span class="la-keyword">init</span>(window: <span class="la-type">UIWindow</span>?) {
        <span class="la-keyword">self</span>.<span class="la-property">window</span> = window
    }
    
    <span class="la-keyword">func</span> start() {
        <span class="la-keyword">let</span> view = <span class="la-type">MasterFactory</span>.<span class="la-call">make</span>(with: <span class="la-keyword">self</span>)
        <span class="la-keyword">let</span> hosting = <span class="la-type">UIHostingController</span>(rootView: view)
        window?.<span class="la-property">rootViewController</span> = hosting
        window?.<span class="la-call">makeKeyAndVisible</span>()
    }
}
</code></pre><p>Here we just take the window and present the <code>rootViewController</code> (<code>UIHostingController</code> is what you need to bring SwiftUI Views to UIKit). The <code>AppCoordinator</code> and the <code>RootMasterCoordinator</code> are the only 2 coordinators where we need UIKit, maybe in <em>June</em> we get a new <code>UISceneDelegate</code>/<code>UIApplicationDelegate</code> API?</p><p>Cool! Coordinators are working via <code>AppCoordinator</code> and <code>RootMasterCoordinator</code>.</p><p>There's an interesting line in <code>RootMasterCoordinator</code>, what's behind that <code>MasterFactory</code>? As you can guess, a factory:</p><pre><code><span class="la-keyword">enum</span> MasterFactory {
    <span class="la-keyword">static func</span> make(with coordinator: <span class="la-type">MasterCoordinator</span>) -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-keyword">let</span> presenter = <span class="la-type">MasterPresenter</span>(coordinator: coordinator)
        <span class="la-keyword">let</span> view = <span class="la-type">MasterView</span>(presenter: presenter)
        <span class="la-keyword">return</span> view
    }
}
</code></pre><p>I'm using an <code>enum</code> so it cannot be initialized, but a <code>struct</code> with an unavailable init also works. Here we get an interesting bit, notice we're returning <code>some View</code>, so we can get the SwiftUI view in <code>RootMasterCoordinator</code>.</p><p>Also, looks like we're injecting our coordinator into the presenter now, in <code>MasterPresenter(coordinator: coordinator)</code>, so let's implement that too:</p><pre><code><span class="la-keyword">final class</span> MasterPresenter: <span class="la-type">MasterPresenting</span> {
    <span class="la-keyword">@Published private(set) var</span> viewModel: <span class="la-type">MasterViewModel</span>
  
    <span class="la-keyword">private let</span> coordinator: <span class="la-type">MasterCoordinator</span>
    
    <span class="la-keyword">init</span>(coordinator: <span class="la-type">MasterCoordinator</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">coordinator</span> = coordinator
        <span class="la-keyword">self</span>.<span class="la-property">viewModel</span> = <span class="la-type">MasterViewModel</span>(date: <span class="la-type">Date</span>())
        <span class="la-comment">// You may want to bind your ViewModel to a service/DB here, maybe using Combine/RxSwift</span>
    }
}
</code></pre><p>As you can see, we inject the coordinator through the init as we did with the window in the coordinator. Then you may want to bind your model/entity here. I tried using <code>onAppear</code> on <code>MasterView</code> and report it back to the presenter as a way to bind the ViewModel, but it works as a <code>viewDidAppear</code> not like a <code>viewDidLoad</code>.</p><p>We've learned how to link everything together, the MVP with the coordinators, now we have the base structure of the UI. <strong>In the next section we'll see how we can navigate to a view.</strong></p><p>This is what we've done so far:</p><pre><code><span class="la-comment">// MARK: Coordinator</span>

<span class="la-keyword">protocol</span> Coordinator {
    <span class="la-keyword">func</span> start()
}

<span class="la-keyword">extension</span> <span class="la-type">Coordinator</span> {
    <span class="la-keyword">func</span> coordinate(to coordinator: <span class="la-type">Coordinator</span>) {
        coordinator.<span class="la-call">start</span>()
    }
}

<span class="la-comment">// MARK: AppCoordinator</span>

<span class="la-keyword">final class</span> AppCoordinator: <span class="la-type">Coordinator</span> {
    <span class="la-keyword">private weak var</span> window: <span class="la-type">UIWindow</span>?
    
    <span class="la-keyword">init</span>(window: <span class="la-type">UIWindow</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">window</span> = window
    }
    
    <span class="la-keyword">func</span> start() {
        <span class="la-keyword">let</span> coordinator = <span class="la-type">RootMasterCoordinator</span>(window: window)
        <span class="la-call">coordinate</span>(to: coordinator)
    }
}

<span class="la-comment">// MARK: MasterCoordinator</span>

<span class="la-keyword">protocol</span> MasterCoordinator: <span class="la-type">Coordinator</span> {}

<span class="la-keyword">final class</span> RootMasterCoordinator: <span class="la-type">MasterCoordinator</span> {
    <span class="la-keyword">private weak var</span> window: <span class="la-type">UIWindow</span>?
    
    <span class="la-keyword">init</span>(window: <span class="la-type">UIWindow</span>?) {
        <span class="la-keyword">self</span>.<span class="la-property">window</span> = window
    }
    
    <span class="la-keyword">func</span> start() {
        <span class="la-keyword">let</span> view = <span class="la-type">MasterFactory</span>.<span class="la-call">make</span>(with: <span class="la-keyword">self</span>)
        <span class="la-keyword">let</span> hosting = <span class="la-type">UIHostingController</span>(rootView: view)
        window?.<span class="la-property">rootViewController</span> = hosting
        window?.<span class="la-call">makeKeyAndVisible</span>()
    }
}

<span class="la-comment">// MARK: Factory</span>

<span class="la-keyword">enum</span> MasterFactory {
    <span class="la-keyword">static func</span> make(with coordinator: <span class="la-type">MasterCoordinator</span>) -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-keyword">let</span> presenter = <span class="la-type">MasterPresenter</span>(coordinator: coordinator)
        <span class="la-keyword">let</span> view = <span class="la-type">MasterView</span>(presenter: presenter)
        <span class="la-keyword">return</span> view
    }
}

<span class="la-comment">// MARK: MVP</span>

<span class="la-keyword">struct</span> MasterViewModel {
    <span class="la-keyword">let</span> date: <span class="la-type">Date</span>
}

<span class="la-keyword">protocol</span> MasterPresenting: <span class="la-type">ObservableObject</span> {
    <span class="la-keyword">var</span> viewModel: <span class="la-type">MasterViewModel</span> { <span class="la-keyword">get</span> }
}

<span class="la-keyword">final class</span> MasterPresenter: <span class="la-type">MasterPresenting</span> {
    <span class="la-keyword">@Published private(set) var</span> viewModel: <span class="la-type">MasterViewModel</span>
  
    <span class="la-keyword">private let</span> coordinator: <span class="la-type">MasterCoordinator</span>
    
    <span class="la-keyword">init</span>(coordinator: <span class="la-type">MasterCoordinator</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">coordinator</span> = coordinator
        <span class="la-keyword">self</span>.<span class="la-property">viewModel</span> = <span class="la-type">MasterViewModel</span>(date: <span class="la-type">Date</span>())
    }
}

<span class="la-keyword">struct</span> MasterView&lt;T: <span class="la-type">MasterPresenting</span>&gt;: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">T</span>
  
    <span class="la-keyword">var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-type">Text</span>(<span class="la-string">"</span>\(presenter.<span class="la-property">viewModel</span>.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>)
    }
}
</code></pre><h2>3. üó∫ Navigating to another view</h2><p>Now that we have our MVP and Coordinators in place, let's go to <code>MasterView</code> and see how we can navigate to another view with <code>NavigationLink</code>:</p><pre><code><span class="la-keyword">struct</span> MasterView&lt;T: <span class="la-type">MasterPresenting</span>&gt;: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">T</span>
  
    <span class="la-keyword">var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-type">NavigationView</span> {
            <span class="la-type">NavigationLink</span>(destination: <span class="la-type">EmptyView</span>()) {
                <span class="la-type">Text</span>(<span class="la-string">"</span>\(presenter.<span class="la-property">viewModel</span>.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>)  
            }
        }
    }
}
</code></pre><p>What's going on here? We're telling <code>MasterView</code> that its content is wrapped in a <code>NavigationView</code>, kind of a <code>UINavigationController</code>. Then with <code>NavigationLink</code>, we create a <code>push</code> action to <code>EmptyView()</code> which is going to be triggered when <code>Text</code> is pressed.</p><p>But we don't want either <code>MasterView</code> to know that is being presented in a <code>NavigationView</code>, or that we're presenting <code>EmptyView()</code>, or that it must use <code>NavigationLink</code> to present it.</p><p>So first, we're going to move <code>NavigationView</code> out. Where should it go? Yup, the coordinator:</p><pre><code><span class="la-keyword">final class</span> RootMasterCoordinator: <span class="la-type">MasterCoordinator</span> {
    <span class="la-keyword">private weak var</span> window: <span class="la-type">UIWindow</span>?
    
    <span class="la-keyword">init</span>(window: <span class="la-type">UIWindow</span>?) {
        <span class="la-keyword">self</span>.<span class="la-property">window</span> = window
    }
    
    <span class="la-keyword">func</span> start() {
        <span class="la-keyword">let</span> view = <span class="la-type">MasterFactory</span>.<span class="la-call">make</span>(with: <span class="la-keyword">self</span>)
        <span class="la-keyword">let</span> navigation = <span class="la-type">NavigationView</span> { view } <span class="la-comment">// Hi! I'm new</span>
        <span class="la-keyword">let</span> hosting = <span class="la-type">UIHostingController</span>(rootView: navigation)
        window?.<span class="la-property">rootViewController</span> = hosting
        window?.<span class="la-call">makeKeyAndVisible</span>()
    }
}

<span class="la-keyword">struct</span> MasterView&lt;T: <span class="la-type">MasterPresenting</span>&gt;: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">T</span>
  
    <span class="la-keyword">var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-comment">// NavigationView is no longer here</span>
        <span class="la-type">NavigationLink</span>(destination: <span class="la-type">EmptyView</span>()) {
            <span class="la-type">Text</span>(<span class="la-string">"</span>\(presenter.<span class="la-property">viewModel</span>.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>)  
        }
    }
}
</code></pre><p>Better. Next, we're going to move <code>NavigationLink</code> out too. It should be a function we can call on the presenter, something like:</p><pre><code><span class="la-keyword">struct</span> MasterView&lt;T: <span class="la-type">MasterPresenting</span>&gt;: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">T</span>
  
    <span class="la-keyword">var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        presenter.<span class="la-call">presentSuperAmazingView</span> {
            <span class="la-type">Text</span>(<span class="la-string">"</span>\(presenter.<span class="la-property">viewModel</span>.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>)  
        }
    }
}
</code></pre><p>But there're 2 problems here. One, it's hard to understand what <code>presentSuperAmazingView</code> does, does it make <code>Text</code> a button? will it push the view? Second, we're working with <code>NavigationLink</code>, but what happens if we want to present a modal?</p><p>The way to present a modal is with a view modifier called <code>.sheet</code>. That's right, to push a view we have a View struct, <code>NavigationView</code>, and to present a modal we have a modifier, <code>.sheet</code>. If there's something I truly want to avoid is the lack of consistency. Maybe I'm too dumb to understand why it's been done like this, but I'm my humble opinion they both should work the same way (and I don't care if it's with structs or modifiers, or both, but use the same thing). So please, please üôèüèª, if you're an Apple Engineer working in SwiftUI reading this, for the sake of consistency, expose them both the same way, thank you.</p><p>Anyway, how can we avoid this nicely? The best way I found is <a href="https://stackoverflow.com/a/61188788/736384">using a <code>.background</code> view inside a Button's content</a>. It's better to see it in code, so now our <code>MasterView</code> looks like this:</p><pre><code><span class="la-keyword">struct</span> MasterView&lt;T: <span class="la-type">MasterPresenting</span>&gt;: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">T</span>
  
    <span class="la-keyword">@State private var</span> isPresented = <span class="la-keyword">false
  
    var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-type">Button</span>(action: {
            <span class="la-keyword">self</span>.<span class="la-property">isPresented</span> = <span class="la-keyword">true</span>
        }) {
            <span class="la-type">Text</span>(<span class="la-string">"</span>\(presenter.<span class="la-property">viewModel</span>.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>) 
                .<span class="la-call">background</span>(
                    <span class="la-comment">// this is the cool part</span>
                    <span class="la-type">NavigationLink</span>(destination: <span class="la-type">EmptyView</span>(), isActive: $isPresented) {
                        <span class="la-type">EmptyView</span>()
                    }
                )
        }
    }
}
</code></pre><p>Wooooow, ok, it looks weird at first, but it'll serve us perfectly and more importantly, it works! Essentially, we're hiding the <code>NavigationLink</code> in the Button Text's background, and the way it works is through <code>isActive</code>. Whenever the button is pressed, it'll switch <code>isPresented</code> to <code>true</code> which will trigger the <code>NavigationLink</code>.</p><p>Cool! We learned how to wrap our view in a <code>NavigationView</code> and how we can implement <code>NavigationLink</code> so it doesn't depend of anything else in the view, that way we can also easly change it to present a modal for example.</p><p>This is what we've done so far:</p><pre><code><span class="la-comment">// MARK: Coordinator</span>

<span class="la-keyword">protocol</span> Coordinator {
    <span class="la-keyword">func</span> start()
}

<span class="la-keyword">extension</span> <span class="la-type">Coordinator</span> {
    <span class="la-keyword">func</span> coordinate(to coordinator: <span class="la-type">Coordinator</span>) {
        coordinator.<span class="la-call">start</span>()
    }
}

<span class="la-comment">// MARK: AppCoordinator</span>

<span class="la-keyword">final class</span> AppCoordinator: <span class="la-type">Coordinator</span> {
    <span class="la-keyword">private weak var</span> window: <span class="la-type">UIWindow</span>?
    
    <span class="la-keyword">init</span>(window: <span class="la-type">UIWindow</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">window</span> = window
    }
    
    <span class="la-keyword">func</span> start() {
        <span class="la-keyword">let</span> coordinator = <span class="la-type">RootMasterCoordinator</span>(window: window)
        <span class="la-call">coordinate</span>(to: coordinator)
    }
}

<span class="la-comment">// MARK: MasterCoordinator</span>

<span class="la-keyword">protocol</span> MasterCoordinator: <span class="la-type">Coordinator</span> {}

<span class="la-keyword">final class</span> RootMasterCoordinator: <span class="la-type">MasterCoordinator</span> {
    <span class="la-keyword">private weak var</span> window: <span class="la-type">UIWindow</span>?
    
    <span class="la-keyword">init</span>(window: <span class="la-type">UIWindow</span>?) {
        <span class="la-keyword">self</span>.<span class="la-property">window</span> = window
    }
    
    <span class="la-keyword">func</span> start() {
        <span class="la-keyword">let</span> view = <span class="la-type">MasterFactory</span>.<span class="la-call">make</span>(with: <span class="la-keyword">self</span>)
        <span class="la-keyword">let</span> navigation = <span class="la-type">NavigationView</span> { view }
        <span class="la-keyword">let</span> hosting = <span class="la-type">UIHostingController</span>(rootView: navigation)
        window?.<span class="la-property">rootViewController</span> = hosting
        window?.<span class="la-call">makeKeyAndVisible</span>()
    }
}

<span class="la-comment">// MARK: Factory</span>

<span class="la-keyword">enum</span> MasterFactory {
    <span class="la-keyword">static func</span> make(with coordinator: <span class="la-type">MasterCoordinator</span>) -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-keyword">let</span> presenter = <span class="la-type">MasterPresenter</span>(coordinator: coordinator)
        <span class="la-keyword">let</span> view = <span class="la-type">MasterView</span>(presenter: presenter)
        <span class="la-keyword">return</span> view
    }
}

<span class="la-comment">// MARK: MVP</span>

<span class="la-keyword">struct</span> MasterViewModel {
    <span class="la-keyword">let</span> date: <span class="la-type">Date</span>
}

<span class="la-keyword">protocol</span> MasterPresenting: <span class="la-type">ObservableObject</span> {
    <span class="la-keyword">var</span> viewModel: <span class="la-type">MasterViewModel</span> { <span class="la-keyword">get</span> }
}

<span class="la-keyword">final class</span> MasterPresenter: <span class="la-type">MasterPresenting</span> {
    <span class="la-keyword">@Published private(set) var</span> viewModel: <span class="la-type">MasterViewModel</span>
  
    <span class="la-keyword">private let</span> coordinator: <span class="la-type">MasterCoordinator</span>
    
    <span class="la-keyword">init</span>(coordinator: <span class="la-type">MasterCoordinator</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">coordinator</span> = coordinator
        <span class="la-keyword">self</span>.<span class="la-property">viewModel</span> = <span class="la-type">MasterViewModel</span>(date: <span class="la-type">Date</span>())
    }
}

<span class="la-keyword">struct</span> MasterView&lt;T: <span class="la-type">MasterPresenting</span>&gt;: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">T</span>
    
    <span class="la-keyword">@State private var</span> isPresented = <span class="la-keyword">false
    
    var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-type">Button</span>(action: {
            <span class="la-keyword">self</span>.<span class="la-property">isPresented</span> = <span class="la-keyword">true</span>
        }) {
            <span class="la-type">Text</span>(<span class="la-string">"</span>\(presenter.<span class="la-property">viewModel</span>.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>)
                .<span class="la-call">background</span>(
                    <span class="la-type">NavigationLink</span>(destination: <span class="la-type">EmptyView</span>(), isActive: $isPresented) {
                        <span class="la-type">EmptyView</span>()
                    }
            )
        }
    }
}
</code></pre><h2>üèÅ Conclusion</h2><p>We've learned how to set up an entire screen with the MVP pattern, we created a base Coordinator protocol, and implemented our first 2 coordinators. We saw how to wrap our view in a <code>NavigationView</code>, and how to implement <code>NavigationLink</code> so it doesn't depend on anything else in the view.</p><p>That's it! <strong>We've completed part 1 of this series.</strong> In the next post we're going to see how to extract that <code>NavigationLink</code> from <code>MasterView</code> and put it in a new coordinator. We'll have to modify our current base <code>Coordinator</code> protocol, and we're going to see how to easily change from a navigation push to a modal presentation without touching the view, are you going to miss it? <strong>Then head over to part 2!</strong></p><p><strong>Go now to the next part of the series (part 2)!</strong>: <a href="https://lascorbe.com/posts/2020-04-28-MVPCoordinators-SwiftUI-part2">https://lascorbe.com/posts/2020-04-28-MVPCoordinators-SwiftUI-part2</a></p><p>Thank you for reading, I hope you liked it.</p><p>Luis.</p></div></div><div class="post-description"><div class="pure-u-md-1-1"><a href="https://twitter.com/intent/tweet?via=lascorbe&text=MVP%20+%20Coordinators%20in%20SwiftUI%20(part%201)&url=https://lascorbe.com/posts/2020-04-27-MVPCoordinators-SwiftUI-part1" target="_blank"><i class="fab fa-twitter l-box social-icon"></i>Share this post on Twitter.</a></div></div></div><div class="footer pure-u-1"><div class="pure-u-1">¬© 2020 Luis Ascorbe</div><div class="pure-u-1">Generated using <a href="https://github.com/johnsundell/publish" target="_blank">Publish</a>. 100% JavaScript-free.</div><div class="pure-u-1"><a href="/feed.rss">RSS</a> | <a href="/about">About</a></div></div></div></body></html>