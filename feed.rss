<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Luis Ascorbe</title><description>Software Developer. Tech Lead. Speaker. Conference Organizer.</description><link>https://lascorbe.com</link><language>en</language><lastBuildDate>Mon, 27 Apr 2020 22:31:08 +0200</lastBuildDate><pubDate>Mon, 27 Apr 2020 22:31:08 +0200</pubDate><ttl>250</ttl><atom:link href="https://lascorbe.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://lascorbe.com/posts/2020-04-27-MVPCoordinators-SwiftUI-part1</guid><title>MVP + Coordinators in SwiftUI (part 1)</title><description>1st part of exploring a MVP+Coordinators approach on SwiftUI without using UIKit.</description><link>https://lascorbe.com/posts/2020-04-27-MVPCoordinators-SwiftUI-part1</link><pubDate>Mon, 27 Apr 2020 12:00:00 +0200</pubDate><content:encoded><![CDATA[<img src="https://lascorbe.com/images/posts/2020-04-26-MVPCoordinators-SwiftUI/1.jpg"/><p><em>Public repo: For those of you who want to check out the code right away here is the repo: <a href="https://github.com/Lascorbe/SwiftUI-MVP-Coordinator">https://github.com/Lascorbe/SwiftUI-MVP-Coordinator</a>.</em></p><p><strong>I didn't want to do much on SwiftUI until the next version is announced</strong> due to my previous experience with Swift, I mean, it'll likely introduce a lot of breaking changes. I still remember the pain of migrating between Swift versions (Swift 3 to 4 anyone?), and I didn't want to live that again.</p><p>But all changed, quarantine arrived and I wanted to give a hand building a new app for a friend. I thought well, it could be nice to try SwiftUI making a real app. I liked what I saw about it until now, but after using it... what a great tool it is! <strong>Something that took you 2 days to do with UIKit now you can do it in 2 hours</strong>, it just boosts development so much. It's what we were waiting for while we were looking at things like hot reloading of our frontend colleagues, or React Native, or Flutter... Plus a declarative layout, nothing left to ask for.</p><p>But in SwiftUI not everything is a land of unicorns, specially when you discover that not only navigation is a bit tied to the views, but <a href="https://twitter.com/Dimillian/status/1184745928739184640?s=20">there're</a> <a href="https://twitter.com/tomatoterrorist/status/1242823885621350401?s=20">some</a> <a href="https://twitter.com/SwiftUILab/status/1156091686151475200?s=20">broken</a> <a href="https://twitter.com/ishabazz/status/1234274177231638529?s=20">things</a> <a href="https://twitter.com/search?q=broken%20swiftui&src=typed_query">between iOS 13 minor versions</a> and other platforms.</p><p>I can't do much about how broken an Apple framework/tool is (above reporting <s>radars</s> <a href="https://feedbackassistant.apple.com">feedbacks</a>), but I can explore <strong>how navigation can be decoupled from Views</strong>, or at least I can try. Also, <a href="https://twitter.com/Lascorbe/status/1253992068814430209?s=20">looks like there's some interest</a>.</p><p>So in this post <strong>I'm going to show you how to use SwiftUI with Coordinators</strong>, and using the MVP design pattern.</p><p>I choose MVP and <a href="https://khanlou.com/2015/10/coordinators-redux/">Coordinators</a>, because I've worked with both, and because Coordinators became the defacto design pattern to route our navigation in a UIKit app (<a href="https://vimeo.com/144116310">thanks Soroush! üòä</a>). I don't know if those 2 are the best design patterns to use with SwiftUI, maybe not, maybe something like redux would fit better, I don't know. But it doesn't hurt to try.</p><p>I'm not going to explain how coordinators work, <a href="https://khanlou.com/2015/10/coordinators-redux/">there're</a> <a href="https://www.hackingwithswift.com/articles/175/advanced-coordinator-pattern-tutorial-ios">several</a> <a href="https://khanlou.com/tag/advanced-coordinators/">blog posts</a> explaining it far better and from smarter people than me which I recommend you to check out if you haven't.</p><p>Anyway, let's go for it, are you ready? Let's create a new project, <strong>in the next section I'm going to explain how to set up our 1st screen with MVP</strong>.</p><h2>1. ‚å®Ô∏è Setting up our 1st screen with MVP</h2><p>With our project created, let's define the 1st view of our app:</p><pre><code><span class="la-keyword">struct</span> MasterView: <span class="la-type">View</span> {
    <span class="la-keyword">var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-type">Text</span>(<span class="la-string">"We will rock the stage at NSSpain again"</span>)
    }
}
</code></pre><p>I really want to try to void words like "just", "easy", "simple", "complex"... but this really is <em>just</em> one label in the middle of the screen.</p><p>Now the model, <em>just</em> storing a date (I'll call them ViewModels because we're at the UI layer):</p><pre><code><span class="la-keyword">struct</span> MasterViewModel {
    <span class="la-keyword">let</span> date: <span class="la-type">Date</span>
}
</code></pre><p>Now the presenter:</p><pre><code><span class="la-keyword">protocol</span> MasterPresenting: <span class="la-type">ObservableObject</span> { <span class="la-comment">// Notice conformance to ObservableObject</span>
    <span class="la-keyword">var</span> viewModel: <span class="la-type">MasterViewModel</span> { <span class="la-keyword">get</span> }
}

<span class="la-keyword">final class</span> MasterPresenter: <span class="la-type">MasterPresenting</span> {
    <span class="la-keyword">@Published private(set) var</span> viewModel: <span class="la-type">MasterViewModel</span>
}
</code></pre><p>Yes, we're doing protocols all the way. This is going to be a small app, but let's treat it as if it was a big one. We declare the protocol of the presenter, so we can inject it in our view, which will make things like testing easier.</p><p>Using the power of Combine, we declared the protocol conformance to <code>ObservableObject</code>. Now we can observe the <code>@Published</code> properties from the view.</p><p>Let's change our view to adopt this presenter protocol:</p><pre><code><span class="la-keyword">struct</span> MasterView: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">MasterPresenting</span> <span class="la-comment">// check out @ObservedObject</span>
  
    <span class="la-keyword">var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-type">Text</span>(<span class="la-string">"</span>\(viewModel.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>)
    }
}
</code></pre><p>To bind this view to the presenter we need the <code>@ObservedObject</code> property wrapper. <code>dateFormatter</code> is just a global <code>DateFormatter</code> defined somewhere else. Now our view is "listening" for whenever our <code>viewModel</code> changes!</p><p>We've completed the MVP part of our first screen. <strong>In the next section we're going to define our base Coordinator type and define our first 2 coordinators</strong>.</p><p>This is what we've done so far:</p><pre><code><span class="la-keyword">struct</span> MasterViewModel {
    <span class="la-keyword">let</span> date: <span class="la-type">Date</span>
}

<span class="la-keyword">protocol</span> MasterPresenting: <span class="la-type">ObservableObject</span> {
    <span class="la-keyword">var</span> viewModel: <span class="la-type">MasterViewModel</span> { <span class="la-keyword">get</span> }
}

<span class="la-keyword">final class</span> MasterPresenter: <span class="la-type">MasterPresenting</span> {
    <span class="la-keyword">@Published private(set) var</span> viewModel: <span class="la-type">MasterViewModel</span>
}

<span class="la-keyword">struct</span> MasterView: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">MasterPresenting</span>
  
    <span class="la-keyword">var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-type">Text</span>(<span class="la-string">"</span>\(viewModel.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>)
    }
}
</code></pre><h2>2. üß≠ Creating Coordinators</h2><p>With our MVP in place, now we are going to create protocols and implementations for coordinators. So how does our base Coordinator look like?</p><pre><code><span class="la-keyword">protocol</span> Coordinator {
    <span class="la-keyword">func</span> start()
}
</code></pre><p>Let's start with something like this. And we extend the protocol to define a coordinate function:</p><pre><code><span class="la-keyword">extension</span> <span class="la-type">Coordinator</span> {
    <span class="la-keyword">func</span> coordinate(to coordinator: <span class="la-type">Coordinator</span>) {
        coordinator.<span class="la-property">parent</span> = <span class="la-keyword">self</span>
        coordinator.<span class="la-call">start</span>()
    }
}
</code></pre><p>Wait, how are you storing parent in a protocol extension? Where is it defined? Bear with me for a moment, we'll get there.</p><p>Next, we can try to implement <code>MasterView</code>'s coordinator:</p><pre><code><span class="la-keyword">protocol</span> MasterCoordinator: <span class="la-type">Coordinator</span> {} <span class="la-comment">// empty for now</span>

<span class="la-keyword">final class</span> RootMasterCoordinator: <span class="la-type">MasterCoordinator</span> {
    <span class="la-keyword">func</span> start() {
        ??
    }
}
</code></pre><p>Hmmm, what can we do here? Let's go to the beginning of the app, the <code>SceneDelegate</code>, and see what we need.</p><pre><code><span class="la-keyword">func</span> scene(<span class="la-keyword">_</span> scene: <span class="la-type">UIScene</span>, willConnectTo session: <span class="la-type">UISceneSession</span>, options connectionOptions: <span class="la-type">UIScene</span>.<span class="la-type">ConnectionOptions</span>) {
    <span class="la-keyword">if let</span> windowScene = scene <span class="la-keyword">as</span>? <span class="la-type">UIWindowScene</span> {
        <span class="la-keyword">let</span> window = <span class="la-type">UIWindow</span>(windowScene: windowScene)
        <span class="la-keyword">let</span> coordinator = <span class="la-type">AppCoordinator</span>(window: window) <span class="la-comment">// &lt;-- look here</span>
        coordinator.<span class="la-call">start</span>()                              <span class="la-comment">// &lt;-- and here</span>
        <span class="la-keyword">self</span>.<span class="la-property">window</span> = window
    }
}
</code></pre><p>The important part is the 2 lines of the coordinator, the initialization, where we inject the window, and <code>coordinator.start()</code>. Now let's define our <code>AppCoordinator</code>, which is going to be the starting point of the app navigation:</p><pre><code><span class="la-keyword">final class</span> AppCoordinator: <span class="la-type">Coordinator</span> {
    <span class="la-keyword">private weak var</span> window: <span class="la-type">UIWindow</span>?
    
    <span class="la-keyword">init</span>(window: <span class="la-type">UIWindow</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">window</span> = window
    }
    
    <span class="la-keyword">func</span> start() {
        <span class="la-keyword">let</span> coordinator = <span class="la-type">RootMasterCoordinator</span>(window: window)
        <span class="la-call">coordinate</span>(to: coordinator)
    }
}
</code></pre><p>We're injecting the <code>UIWindow</code> through the <code>init</code>, and then passing it to <code>MasterView</code>'s coordinator.</p><p>Next, we have to handle the presentation on the window. Let's go back to our <code>RootMasterCoordinator</code> and set up the <code>start()</code> function:</p><pre><code><span class="la-keyword">final class</span> RootMasterCoordinator: <span class="la-type">MasterCoordinator</span> {
    <span class="la-keyword">private weak var</span> window: <span class="la-type">UIWindow</span>?
    
    <span class="la-keyword">init</span>(window: <span class="la-type">UIWindow</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">window</span> = window
    }
    
    <span class="la-keyword">func</span> start() {
        <span class="la-keyword">let</span> view = <span class="la-type">MasterFactory</span>.<span class="la-call">make</span>(with: <span class="la-keyword">self</span>)
        <span class="la-keyword">let</span> hosting = <span class="la-type">UIHostingController</span>(rootView: view)
        window?.<span class="la-property">rootViewController</span> = hosting
        window?.<span class="la-call">makeKeyAndVisible</span>()
    }
}
</code></pre><p>Here we just take the window and present the <code>rootViewController</code> (<code>UIHostingController</code> is what you need to bring SwiftUI Views to UIKit). The <code>AppCoordinator</code> and the <code>RootMasterCoordinator</code> are the only 2 coordinators where we need UIKit, maybe in <em>June</em> we get a new <code>UISceneDelegate</code>/<code>UIApplicationDelegate</code> API?</p><p>Cool! Coordinators are working via <code>AppCoordinator</code> and <code>RootMasterCoordinator</code>.</p><p>There's an interesting line in <code>RootMasterCoordinator</code>, what's behind that <code>MasterFactory</code>? As you can guess, a factory:</p><pre><code><span class="la-keyword">enum</span> MasterFactory {
    <span class="la-keyword">static func</span> make(with coordinator: <span class="la-type">Coordinator</span>) -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-keyword">let</span> presenter = <span class="la-type">MasterPresenter</span>(coordinator: coordinator)
        <span class="la-keyword">let</span> view = <span class="la-type">MasterView</span>(presenter: presenter)
        <span class="la-keyword">return</span> view
    }
}
</code></pre><p>I'm using an <code>enum</code> so it cannot be initialized, but a <code>struct</code> with an unavailable init also works. Here we get an interesting bit, notice we're returning <code>some View</code>, so we can get the SwiftUI view in <code>RootMasterCoordinator</code>.</p><p>Also, looks like we're injecting our coordinator into the presenter now, in <code>MasterPresenter(coordinator: coordinator)</code>, so let's implement that too:</p><pre><code><span class="la-keyword">final class</span> MasterPresenter: <span class="la-type">MasterPresenting</span> {
    <span class="la-keyword">@Published private(set) var</span> viewModel: <span class="la-type">MasterViewModel</span>
  
    <span class="la-keyword">private let</span> coordinator: <span class="la-type">MasterCoordinator</span>
    
    <span class="la-keyword">init</span>(coordinator: <span class="la-type">MasterCoordinator</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">coordinator</span> = coordinator
        <span class="la-comment">// You may want to bind your viewModel to a service/DB here, maybe using Combine/RxSwift</span>
    }
}
</code></pre><p>As you can see, we inject the coordinator through the init as we did with the window in the coordinator. Then you may want to bind your model/entity here. I tried using <code>onAppear</code> on <code>MasterView</code> and report it back to the presenter as a way to bind the ViewModel, but it works as a <code>viewDidAppear</code> not like a <code>viewDidLoad</code>.</p><p>We've learned how to link everything together, the MVP with the coordinators, now we have the base structure of the UI. <strong>In the next section we'll see how we can navigate to a view.</strong></p><p>This is what we've done so far:</p><pre><code><span class="la-comment">// MARK: Coordinators</span>

<span class="la-keyword">final class</span> AppCoordinator: <span class="la-type">Coordinator</span> {
    <span class="la-keyword">private weak var</span> window: <span class="la-type">UIWindow</span>?
    
    <span class="la-keyword">init</span>(window: <span class="la-type">UIWindow</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">window</span> = window
    }
    
    <span class="la-keyword">func</span> start() {
        <span class="la-keyword">let</span> coordinator = <span class="la-type">RootMasterCoordinator</span>(window: window)
        <span class="la-call">coordinate</span>(to: coordinator)
    }
}

<span class="la-keyword">final class</span> RootMasterCoordinator: <span class="la-type">MasterCoordinator</span> {
    <span class="la-keyword">private weak var</span> window: <span class="la-type">UIWindow</span>?
    
    <span class="la-keyword">init</span>(window: <span class="la-type">UIWindow</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">window</span> = window
    }
    
    <span class="la-keyword">func</span> start() {
        <span class="la-keyword">let</span> view = <span class="la-type">MasterFactory</span>.<span class="la-call">make</span>(with: <span class="la-keyword">self</span>)
        <span class="la-keyword">let</span> hosting = <span class="la-type">UIHostingController</span>(rootView: view)
        window?.<span class="la-property">rootViewController</span> = hosting
        window?.<span class="la-call">makeKeyAndVisible</span>()
    }
}

<span class="la-comment">// MARK: Factory</span>

<span class="la-keyword">enum</span> MasterFactory {
    <span class="la-keyword">static func</span> make(with coordinator: <span class="la-type">Coordinator</span>) -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-keyword">let</span> presenter = <span class="la-type">MasterPresenter</span>(coordinator: coordinator)
        <span class="la-keyword">let</span> view = <span class="la-type">MasterView</span>(presenter: presenter)
        <span class="la-keyword">return</span> view
    }
}

<span class="la-comment">// MARK: MVP</span>

<span class="la-keyword">struct</span> MasterViewModel {
    <span class="la-keyword">let</span> date: <span class="la-type">Date</span>
}

<span class="la-keyword">protocol</span> MasterPresenting: <span class="la-type">ObservableObject</span> {
    <span class="la-keyword">var</span> viewModel: <span class="la-type">MasterViewModel</span> { <span class="la-keyword">get</span> }
}

<span class="la-keyword">final class</span> MasterPresenter: <span class="la-type">MasterPresenting</span> {
    <span class="la-keyword">@Published private(set) var</span> viewModel: <span class="la-type">MasterViewModel</span>
  
    <span class="la-keyword">private let</span> coordinator: <span class="la-type">MasterCoordinator</span>
    
    <span class="la-keyword">init</span>(coordinator: <span class="la-type">MasterCoordinator</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">coordinator</span> = coordinator
    }
}

<span class="la-keyword">struct</span> MasterView: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">MasterPresenting</span>
  
    <span class="la-keyword">var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-type">Text</span>(<span class="la-string">"</span>\(viewModel.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>)
    }
}
</code></pre><h2>3. üó∫ Navigating to another view</h2><p>Now that we have our MVP and Coordinators in place, let's go to <code>MasterView</code> and see how we can navigate to another view with <code>NavigationLink</code>:</p><pre><code><span class="la-keyword">struct</span> MasterView: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">MasterPresenting</span>
  
    <span class="la-keyword">var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-type">NavigationView</span> {
            <span class="la-type">NavigationLink</span>(destination: <span class="la-type">EmptyView</span>()) {
                <span class="la-type">Text</span>(<span class="la-string">"</span>\(viewModel.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>)  
            }
        }
    }
}
</code></pre><p>What's going on here? We're telling <code>MasterView</code> that its content is wrapped in a <code>NavigationView</code>, kind of a <code>UINavigationController</code>. Then with <code>NavigationLink</code>, we create a <code>push</code> action to <code>EmptyView()</code> which is going to be triggered when <code>Text</code> is pressed.</p><p>But we don't want either <code>MasterView</code> to know that is being presented in a <code>NavigationView</code>, or that we're presenting <code>EmptyView()</code>, or that it must use <code>NavigationLink</code> to present it.</p><p>So first, we're going to move <code>NavigationView</code> out. Where should it go? Yup, the coordinator:</p><pre><code><span class="la-keyword">final class</span> RootMasterCoordinator: <span class="la-type">MasterCoordinator</span> {
    <span class="la-keyword">private weak var</span> window: <span class="la-type">UIWindow</span>?
    
    <span class="la-keyword">init</span>(window: <span class="la-type">UIWindow</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">window</span> = window
    }
    
    <span class="la-keyword">func</span> start() {
        <span class="la-keyword">let</span> view = <span class="la-type">MasterFactory</span>.<span class="la-call">make</span>(with: <span class="la-keyword">self</span>)
        <span class="la-keyword">let</span> navigation = <span class="la-type">NavigationView</span> { view } <span class="la-comment">// Hi! I'm new</span>
        <span class="la-keyword">let</span> hosting = <span class="la-type">UIHostingController</span>(rootView: navigation)
        window?.<span class="la-property">rootViewController</span> = hosting
        window?.<span class="la-call">makeKeyAndVisible</span>()
    }
}

<span class="la-keyword">struct</span> MasterView: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">MasterPresenting</span>
  
    <span class="la-keyword">var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-comment">// NavigationView is no longer here</span>
        <span class="la-type">NavigationLink</span>(destination: <span class="la-type">EmptyView</span>()) {
            <span class="la-type">Text</span>(<span class="la-string">"</span>\(viewModel.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>)  
        }
    }
}
</code></pre><p>Better. Next, we're going to move <code>NavigationLink</code> out too. It should be a function we can call on the presenter, something like:</p><pre><code><span class="la-keyword">struct</span> MasterView: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">MasterPresenting</span>
  
    <span class="la-keyword">var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        presenter.<span class="la-call">presentSuperAmazingView</span> {
            <span class="la-type">Text</span>(<span class="la-string">"</span>\(viewModel.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>)  
        }
    }
}
</code></pre><p>But there're 2 problems here. One, it's hard to understand what <code>presentSuperAmazingView</code> does, does it make <code>Text</code> a button? will it push the view? Second, we're working with <code>NavigationLink</code>, but what happens if we want to present a modal?</p><p>The way to present a modal is with a view modifier called <code>.sheet</code>. That's right, to push a view we have a View struct, <code>NavigationView</code>, and to present a modal we have a modifier, <code>.sheet</code>. If there's something I truly want to avoid is the lack of consistency. Maybe I'm too dumb to understand why it's been done like this, but I'm my humble opinion they both should work the same way (and I don't care if it's with structs or modifiers, or both, but use the same thing). So please, please üôèüèª, if you're an Apple Engineer working in SwiftUI reading this, for the sake of consistency, expose them both the same way, thank you.</p><p>Anyway, how can we avoid this nicely? The best way I found is <a href="https://stackoverflow.com/a/61188788/736384">using a <code>.background</code> view inside a Button's content</a>. It's better to see it in code, so now our <code>MasterView</code> looks like this:</p><pre><code><span class="la-keyword">struct</span> MasterView: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">MasterPresenting</span>
  
    <span class="la-keyword">@State private var</span> isPresented = <span class="la-keyword">false
  
    var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-type">Button</span>(action: {
            <span class="la-keyword">self</span>.<span class="la-property">isPresented</span> = <span class="la-keyword">true</span>
        }) {
            <span class="la-type">Text</span>(<span class="la-string">"</span>\(viewModel.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>) 
                .<span class="la-call">background</span>(
                    <span class="la-comment">// this is the cool part</span>
                    <span class="la-type">NavigationLink</span>(destination: <span class="la-type">EmptyView</span>(), isActive: $isPresented) {
                        <span class="la-type">EmptyView</span>()
                    }
                )
        }
    }
}
</code></pre><p>Wooooow, ok, it looks weird at first, but it'll serve us perfectly and more importantly, it works! Essentially, we're hiding the <code>NavigationLink</code> in the Button Text's background, and the way it works is through <code>isActive</code>. Whenever the button is pressed, it'll switch <code>isPresented</code> to <code>true</code> which will trigger the <code>NavigationLink</code>.</p><p>Cool! We learned how to wrap our view in a <code>NavigationView</code> and how we can implement <code>NavigationLink</code> so it doesn't depend of anything else in the view, that way we can also easly change it to present a modal for example.</p><p>This is what we've done so far:</p><pre><code><span class="la-comment">// MARK: Coordinators</span>

<span class="la-keyword">final class</span> AppCoordinator: <span class="la-type">Coordinator</span> {
    <span class="la-keyword">private weak var</span> window: <span class="la-type">UIWindow</span>?
    
    <span class="la-keyword">init</span>(window: <span class="la-type">UIWindow</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">window</span> = window
    }
  
    <span class="la-keyword">func</span> start() {
        <span class="la-keyword">let</span> coordinator = <span class="la-type">RootMasterCoordinator</span>(window: window)
        <span class="la-call">coordinate</span>(to: coordinator)
    }
}

<span class="la-keyword">final class</span> RootMasterCoordinator: <span class="la-type">MasterCoordinator</span> {
    <span class="la-keyword">private weak var</span> window: <span class="la-type">UIWindow</span>?
    
    <span class="la-keyword">init</span>(window: <span class="la-type">UIWindow</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">window</span> = window
    }
    
    <span class="la-keyword">func</span> start() {
        <span class="la-keyword">let</span> view = <span class="la-type">MasterFactory</span>.<span class="la-call">make</span>(with: <span class="la-keyword">self</span>)
        <span class="la-keyword">let</span> navigation = <span class="la-type">NavigationView</span> { view }
        <span class="la-keyword">let</span> hosting = <span class="la-type">UIHostingController</span>(rootView: navigation)
        window?.<span class="la-property">rootViewController</span> = hosting
        window?.<span class="la-call">makeKeyAndVisible</span>()
    }
}

<span class="la-comment">// MARK: Factory</span>

<span class="la-keyword">enum</span> MasterFactory {
    <span class="la-keyword">static func</span> make(with coordinator: <span class="la-type">Coordinator</span>) -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-keyword">let</span> presenter = <span class="la-type">MasterPresenter</span>(coordinator: coordinator)
        <span class="la-keyword">let</span> view = <span class="la-type">MasterView</span>(presenter: presenter)
        <span class="la-keyword">return</span> view
    }
}

<span class="la-comment">// MARK: MVP</span>

<span class="la-keyword">struct</span> MasterViewModel {
    <span class="la-keyword">let</span> date: <span class="la-type">Date</span>
}

<span class="la-keyword">protocol</span> MasterPresenting: <span class="la-type">ObservableObject</span> {
    <span class="la-keyword">var</span> viewModel: <span class="la-type">MasterViewModel</span> { <span class="la-keyword">get</span> }
}

<span class="la-keyword">final class</span> MasterPresenter: <span class="la-type">MasterPresenting</span> {
    <span class="la-keyword">@Published private(set) var</span> viewModel: <span class="la-type">MasterViewModel</span>
  
    <span class="la-keyword">private let</span> coordinator: <span class="la-type">MasterCoordinator</span>
    
    <span class="la-keyword">init</span>(coordinator: <span class="la-type">MasterCoordinator</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">coordinator</span> = coordinator
    }
}

<span class="la-keyword">struct</span> MasterView: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">MasterPresenting</span>
  
    <span class="la-keyword">@State private var</span> isPresented = <span class="la-keyword">false
  
    var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-type">Button</span>(action: {
            <span class="la-keyword">self</span>.<span class="la-property">isPresented</span> = <span class="la-keyword">true</span>
        }) {
            <span class="la-type">Text</span>(<span class="la-string">"</span>\(viewModel.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>) 
                .<span class="la-call">background</span>(
                    <span class="la-comment">// this is the cool part</span>
                    <span class="la-type">NavigationLink</span>(destination: <span class="la-type">EmptyView</span>(), isActive: $isPresented) {
                        <span class="la-type">EmptyView</span>()
                    }
                )
        }
    }
}
</code></pre><h2>üèÅ Conclusion</h2><p>We've learned how to set up an entire screen with the MVP pattern, we created our base Coordinator and our first 2 coordinators, and we saw how to wrap our view in a <code>NavigationView</code> and how we can implement <code>NavigationLink</code> so it doesn't depend of anything else in the view.</p><p>That's it! <strong>We've completed part 1 of this series.</strong> In the next post we're going to see how to extract that <code>NavigationLink</code> from <code>MasterView</code> and put it in a new Coordinator. We'll have to modify our current base Coordinator protocol, and we're going to see how to easily change from a navigation push to a modal presentation without touching the view, are you going to miss it?</p><p>Thank you for reading, I hope you liked it.</p><p>Luis.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://lascorbe.com/posts/2020-04-21-hello-world</guid><title>Hello world!</title><description>Hi there from the trenches! üëã</description><link>https://lascorbe.com/posts/2020-04-21-hello-world</link><pubDate>Tue, 21 Apr 2020 13:00:00 +0200</pubDate><content:encoded><![CDATA[<p>Hi there!</p><p>Welcome to my new blog. Thank you for wasting your time reading me, I mean, I'm pretty sure there's a new Netflix documentary that you haven't seen way more interesting than reading what an average human being from Spain could write. So thank you for reading üòä.<br><br>Why I made this? This is my 3rd or 4th attempt at trying to start a blog. I hope to be more consistent and write often. The good thing is that this is the first time I make a blog by myself, on my domain (years ago I used Blogger and Medium). So let's see how this goes üòÉ.</p><p>What about the content? I'm not completely sure if this is going to be a purely technical blog or I'm going to write about other things, I'll figure it out while driving. Anyway, for now, the topics will be mostly technical, I'm exploring SwiftUI so I think that's what I'm going to start with.</p><p>What about how I made this website? I made it entirely with <a href="https://github.com/JohnSundell/Publish">Publish</a>, a great tool to make websites with Swift, by my buddy <a href="https://twitter.com/JohnSundell">John Sundell</a>. Check it out, it's modular and versatile, John did an amazing job building it.</p><p>If you want to know how to make your website with <a href="https://github.com/JohnSundell/Publish">Publish</a>, 2 articles helped me to get started:</p><ul><li><a href="https://blog.bitomule.com/posts/getting-started-with-publish/">Getting started with publish</a> by my friend <a href="https://twitter.com/Bitomule">David Collado</a>.</li><li><a href="https://www.staskus.io/posts/2020-01-26-publish/">Migrating from Jekyll to Publish: A site generator for Swift developers</a> by <a href="https://twitter.com/PovilasStaskus">Povilas Staskus</a>.</li></ul><p>If you've reached this point chances are that you've completed Netflix and you do not have anything else to do, so here's a recommendation: go watch <a href="https://documentaryheaven.com/objectified/">Objectified</a> if you haven't yet. A great documentary on design and our relationships with products. Or you can always go to the <a href="https://vimeo.com/nsspain">NSSpain Vimeo channel</a> and watch a talk üòá.</p><p>Cheers ‚úåÔ∏è.</p>]]></content:encoded></item></channel></rss>